<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能体12要素 - 构建可靠LLM应用的原则</title>
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-100-M/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/mermaid/8.14.0/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
        }
        .serif {
            font-family: 'Noto Serif SC', serif;
        }
        .dark {
            background-color: #1a1a1a;
            color: #f5f5f5;
        }
        .gradient-text {
            background: linear-gradient(45deg, #3B82F6, #8B5CF6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .card-hover {
            transition: all 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
        }
        .highlight {
            background: linear-gradient(120deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border-left: 4px solid #3B82F6;
        }
    </style>
</head>
<body class="max-w-7xl mx-auto bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
    <!-- 导航栏 -->
    <nav class="bg-white dark:bg-gray-800 shadow-md fixed w-full z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <a href="#" class="text-lg font-bold text-gray-800 dark:text-white">智能体12要素</a>
            <div class="flex items-center space-x-4">
                <button id="themeToggle" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700">
                    <i class="fas fa-moon dark:hidden"></i>
                    <i class="fas fa-sun hidden dark:block"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Hero 部分 -->
    <header class="pt-24 pb-12 px-4">
        <div class="container mx-auto">
            <h1 class="text-4xl md:text-5xl font-bold text-center mb-6 gradient-text">智能体12要素</h1>
            <p class="text-lg text-center text-gray-600 dark:text-gray-300 max-w-3xl mx-auto">
                构建可靠LLM应用的原则
            </p>
        </div>
    </header>

    <!-- 主要内容 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 简介部分 -->
        <section class="m b">
            <h2 class="text-2xl  font-bold mb-6 serif gradient-text">简介</h2>
            <div class="prose dark:prose-invert max-w-none">
                <p class="text-lg mb-4">
                    欢迎来到智能体12要素。这是我在一年来与智能体合作的经验总结，随着我们的探索，这些原则可能会不断演进。
                </p>
                <div class="highlight p-4 rounded-lg mb-6">
                    <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">核心问题：</p>
                    <p class="text-lg">
                        我们可以使用哪些原则来构建足够可靠的LLM驱动软件，使其能够投入生产环境？
                    </p>
                </div>
            </div>
        </section>

        <!-- 12要素概览 -->
        <section class="mb-12">
            <h2 class="text-2xl  font-bold mb-6 serif gradient-text">12要素概览</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- 要素1卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">1</div>
                        <h3 class="text-lg font-bold">自然语言到工具调用</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        将自然语言转换为结构化的工具调用，使智能体能够理解并执行任务。
                    </p>
                </div>
                <!-- 要素2卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">2</div>
                        <h3 class="text-lg font-bold">掌控你的提示词</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        不要将提示词工程外包给框架，而应将其视为一等公民并完全掌控。
                    </p>
                </div>
                <!-- 要素3卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">3</div>
                        <h3 class="text-lg font-bold">掌控上下文窗口</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        自定义上下文格式，优化信息密度和LLM理解效率，实现更高效的交互。
                    </p>
                </div>
                <!-- 要素4卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">4</div>
                        <h3 class="text-lg font-bold">工具即结构化输出</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        工具本质上只是LLM的结构化输出，用于触发确定性代码执行。
                    </p>
                </div>
                <!-- 要素5卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">5</div>
                        <h3 class="text-lg font-bold">统一执行状态和业务状态</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        尽可能简化状态管理，将执行状态和业务状态统一起来，减少复杂性。
                    </p>
                </div>
                <!-- 要素6卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">6</div>
                        <h3 class="text-lg font-bold">简单的启动/暂停/恢复API</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        提供简单的API接口，使智能体能够轻松启动、暂停和恢复，支持与其他系统的无缝集成。
                    </p>
                </div>
                <!-- 要素7卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">7</div>
                        <h3 class="text-lg font-bold">通过工具调用联系人类</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        使用结构化的工具调用来实现人机交互，支持更灵活的工作流程和多人协作。
                    </p>
                </div>
                <!-- 要素8卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">8</div>
                        <h3 class="text-lg font-bold">掌控控制流</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        构建适合特定用例的控制结构，实现更自然的对话和工作流程。
                    </p>
                </div>
                <!-- 要素9卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">9</div>
                        <h3 class="text-lg font-bold">错误处理与上下文</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        将错误信息整合到上下文窗口中，实现智能体的自我修复能力。
                    </p>
                </div>
                <!-- 要素10卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">10</div>
                        <h3 class="text-lg font-bold">小型专注智能体</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        构建小型、专注的智能体，每个智能体专注于做好一件事，而不是构建试图做所有事情的单一智能体。
                    </p>
                </div>
                <!-- 要素11卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">11</div>
                        <h3 class="text-lg font-bold">随处触发，触达用户</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        让用户能够从任何渠道（Slack、邮件、短信等）触发智能体，并通过相同渠道获得响应。
                    </p>
                </div>
                <!-- 要素12卡片 -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 card-hover">
                    <div class="flex items-center mb-3">
                        <div class="w-6 h-6 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3">12</div>
                        <h3 class="text-lg font-bold">无状态归约器</h3>
                    </div>
                    <p class="text-gray-600 dark:text-gray-300">
                        将智能体设计为无状态归约器，使其能够以函数式编程的方式处理输入和输出。
                    </p>
                </div>
            </div>
        </section>

        <!-- 要素详解 -->
        <section class="mb-12">
            <h2 class="text-2xl  font-bold mb-6 serif gradient-text">要素详解</h2>
            
            <!-- 要素1详解 -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
                <div class="flex items-center mb-4">
                    <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-l g">1</div>
                    <h3 class="text-2xl font-bold">自然语言到工具调用</h3>
                </div>
                <div class="prose dark:prose-invert max-w-none">
                    <p class="mb-4">
                        这是智能体构建中最常见的模式之一，它允许你将自然语言转换为结构化的工具调用。
                    </p>
                    
                    <div class="my-6">
                        <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/main/img/110-natural-language-tool-calls.png" 
                             alt="自然语言到工具调用示意图" 
                             class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
                    </div>

                    <div class="highlight p-4 rounded-lg mb-6">
                        <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">示例：</p>
                        <p class="mb-2">自然语言输入：</p>
                        <p class="italic mb-4 text-gray-700 dark:text-gray-300">"can you create a payment link for $750 to Terri for sponsoring the february AI tinkerers meetup?"</p>
                        
                        <p class="mb-2">转换为结构化输出：</p>
                        <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
{
  "function": {
    "name": "create_payment_link",
    "parameters": {
      "amount": 750,
      "customer": "cust_128934ddasf9",
      "product": "prod_8675309",
      "price": "prc_09874329fds",
      "quantity": 1,
      "memo": "Hey Jeff - see below for the payment link for the february ai tinkerers meetup"
    }
  }
}</pre>
                    </div>
                </div>
            </div>

            <!-- 要素2详解 -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
        <div class="flex items-center mb-4">
            <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">2</div>
            <h3 class="text-2xl font-bold">掌控你的提示词</h3>
        </div>
        <div class="prose dark:prose-invert max-w-none">
            <p class="mb-4">
                不要将提示词工程外包给框架。虽然一些框架提供了"黑盒"式的解决方案，但为了获得最佳效果，你应该将提示词视为一等公民。
            </p>
            
            <div class="my-6">
                <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/main/img/120-own-your-prompts.png" 
                     alt="掌控提示词示意图" 
                     class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
            </div>
            <div class="highlight p-4 rounded-lg mb-6">
                <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">框架示例：</p>
                <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
agent = Agent(
  role="...",
  goal="...",
  personality="...",
  tools=[tool1, tool2, tool3]
)
task = Task(
  instructions="...",
  expected_output=OutputModel
)
result = agent.run(task)</pre>
            </div>
            <div class="highlight p-4 rounded-lg mb-6">
                <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">更好的方式：</p>
                <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
function DetermineNextStep(thread: string) -> DoneForNow | ListGitTags | DeployBackend | DeployFrontend | RequestMoreInformation {
  prompt #"
    {{ _.role("system") }}
    
    You are a helpful assistant that manages deployments for frontend and backend systems.
    You work diligently to ensure safe and successful deployments by following best practices
    and proper deployment procedures.
    
    Before deploying any system, you should check:
    - The deployment environment (staging vs production)
    - The correct tag/version to deploy
    - The current system status
    
    You can use tools like deploy_backend, deploy_frontend, and check_deployment_status
    to manage deployments. For sensitive deployments, use request_approval to get
    human verification.
    
    Always think about what to do first, like:
    - Check current deployment status
    - Verify the deployment tag exists
    - Request approval if needed
    - Deploy to staging before production
    - Monitor deployment progress
    
    {{ _.role("user") }}
    {{ thread }}
    
    What should the next step be?
  "#
}</pre>
            </div>
            <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
                <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">掌控提示词的主要优势：</h4>
                <ul class="list-disc pl-6 space-y-2">
                    <li><strong>完全控制</strong>：编写你的智能体需要的精确指令，没有黑盒抽象</li>
                    <li><strong>测试和评估</strong>：像对待其他代码一样为提示词构建测试和评估</li>
                    <li><strong>迭代</strong>：根据实际性能快速修改提示词</li>
                    <li><strong>透明度</strong>：确切知道你的智能体正在使用什么指令</li>
                    <li><strong>角色利用</strong>：利用支持非标准用户/助手角色使用的API</li>
                </ul>
            </div>
            <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                <p class="text-blue-800 dark:text-blue-200">
                    <strong>记住：</strong> 你的提示词是应用程序逻辑和LLM之间的主要接口。完全控制提示词可以为你提供生产级智能体所需的灵活性和提示控制。
                </p>
            </div>
        </div>
    </div>

<!-- 要素3详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">3</div>
        <h3 class="text-2xl font-bold">掌控上下文窗口</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <p class="mb-4">
            你不需要使用标准的基于消息的格式来向LLM传递上下文。在任何给定时刻，你对LLM的输入都是"这是到目前为止发生的事情，下一步是什么"。
        </p>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心观点：</strong> 一切都是上下文工程。LLM是将输入转换为输出的无状态函数。要获得最佳输出，你需要提供最佳输入。
            </p>
        </div>

        <div class="my-6">
            <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/main/img/220-context-engineering.png" 
                 alt="上下文工程示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">创建优秀上下文的关键要素：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li>给模型的提示和指令</li>
                <li>检索的文档或外部数据（如RAG）</li>
                <li>任何过去的状态、工具调用、结果或其他历史记录</li>
                <li>来自相关但独立的历史/对话的过去消息或事件（记忆）</li>
                <li>关于输出结构化数据的指令</li>
            </ul>
        </div>

        <div class="highlight p-4 rounded-lg mb-6">
            <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">标准上下文格式示例：</p>
            <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
[
  {
    "role": "system",
    "content": "You are a helpful assistant..."
  },
  {
    "role": "user",
    "content": "Can you deploy the backend?"
  },
  {
    "role": "assistant",
    "content": null,
    "tool_calls": [
      {
        "id": "1",
        "name": "list_git_tags",
        "arguments": "{}"
      }
    ]
  }
]</pre>
        </div>

        <div class="highlight p-4 rounded-lg mb-6">
            <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">自定义上下文格式示例：</p>
            <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
[
  {
    "role": "system",
    "content": "You are a helpful assistant..."
  },
  {
    "role": "user",
    "content": |
            Here's everything that happened so far:
        
        <slack_message>
            From: @alex
            Channel: #deployments
            Text: Can you deploy the backend?
        </slack_message>
        
        <list_git_tags>
            intent: "list_git_tags"
        </list_git_tags>
        
        <list_git_tags_result>
            tags:
              - name: "v1.2.3"
                commit: "abc123"
                date: "2024-03-15T10:00:00Z"
        </list_git_tags_result>
        
        what's the next step?
    }
]</pre>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">掌控上下文窗口的主要优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>信息密度</strong>：以最大化LLM理解的方式构建信息</li>
                <li><strong>错误处理</strong>：以帮助LLM恢复的格式包含错误信息</li>
                <li><strong>安全性</strong>：控制传递给LLM的信息，过滤敏感数据</li>
                <li><strong>灵活性</strong>：根据用例需求调整格式</li>
                <li><strong>Token效率</strong>：优化上下文格式以提高token效率和LLM理解</li>
            </ul>
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>记住：</strong> 上下文窗口是你与LLM的主要接口。控制信息的结构和呈现方式可以显著提高智能体的性能。
            </p>
        </div>
    </div>
</div>
<!-- 要素4详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">4</div>
        <h3 class="text-2xl font-bold">工具即结构化输出</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <p class="mb-4">
            工具不需要很复杂。本质上，它们只是LLM的结构化输出，用于触发确定性代码执行。
        </p>

        <div class="my-6">
            <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/main/img/140-tools-are-just-structured-outputs.png" 
                 alt="工具即结构化输出示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 让LLM"使用多个工具之一"本质上就是让它输出可以被解析成代表这些工具的对象JSON。
            </p>
        </div>

        <div class="highlight p-4 rounded-lg mb-6">
            <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">工具定义示例：</p>
            <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
class Issue:
  title: str
  description: str
  team_id: str
  assignee_id: str

class CreateIssue:
  intent: "create_issue"
  issue: Issue

class SearchIssues:
  intent: "search_issues"
  query: str
  what_youre_looking_for: str</pre>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">基本模式：</h4>
            <ol class="list-decimal pl-6 space-y-2">
                <li>LLM输出结构化JSON</li>
                <li>确定性代码执行相应操作（如调用外部API）</li>
                <li>捕获结果并将其反馈到上下文中</li>
            </ol>
        </div>

        <div class="highlight p-4 rounded-lg mb-6">
            <p class="font-semibold mb-2 text-blue-600 dark:text-blue-400">执行示例：</p>
            <pre class="bg-gray-200 dark:bg-gray-600 p-4 rounded-lg overflow-x-auto">
if nextStep.intent == 'create_payment_link':
    stripe.paymentlinks.create(nextStep.parameters)
    return # 或其他操作
elif nextStep.intent == 'wait_for_a_while': 
    # 执行等待操作
else: # 模型调用了未知工具
    # 执行其他操作</pre>
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>关键点：</strong> 这种方式在LLM的决策和应用程序的操作之间创建了清晰的分离。LLM决定做什么，而你的代码控制如何做。仅仅因为LLM"调用了工具"并不意味着你必须每次都以相同的方式执行特定的对应函数。
            </p>
        </div>
    </div>
</div>
<!-- 要素5详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">5</div>
        <h3 class="text-2xl font-bold">统一执行状态和业务状态</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <p class="mb-4">
            即使在AI领域之外，许多基础设施系统也试图将"执行状态"与"业务状态"分开。对于AI应用，这可能涉及复杂的抽象来跟踪当前步骤、下一步、等待状态、重试次数等。这种分离可能会带来复杂性，但对于你的用例来说可能有些过度。
        </p>

        <div class="my-6">
            <img src="https://raw.githubusercontent.com/humanlayer/12-factor-agents/main/img/155-unify-state-animation.gif" 
                 alt="统一状态动画演示" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 实际上，你可以设计应用程序，使其能够从上下文窗口中推断出所有执行状态。在许多情况下，执行状态（当前步骤、等待状态等）只是关于已发生事情的元数据。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">状态类型：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>执行状态：</strong> 当前步骤、下一步、等待状态、重试次数等</li>
                <li><strong>业务状态：</strong> 智能体工作流程中已发生的事情（如OpenAI消息列表、工具调用和结果列表等）</li>
            </ul>
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>简化原则：</strong> 尽可能统一这些状态。虽然可能有些内容（如会话ID、密码上下文等）不能放入上下文窗口，但你的目标应该是尽量减少这些内容。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">统一状态的主要优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>简单性：</strong> 所有状态的一个真实来源</li>
                <li><strong>序列化：</strong> 线程可以轻松序列化/反序列化</li>
                <li><strong>调试：</strong> 整个历史记录在一个地方可见</li>
                <li><strong>灵活性：</strong> 只需添加新的事件类型即可轻松添加新状态</li>
                <li><strong>恢复：</strong> 只需加载线程即可从任何点恢复</li>
                <li><strong>分叉：</strong> 可以通过将线程的某个子集复制到新的上下文/状态ID来在任何点分叉线程</li>
                <li><strong>人机界面和可观察性：</strong> 可以轻松将线程转换为人类可读的markdown或丰富的Web应用UI</li>
            </ul>
        </div>
    </div>
</div>
<!-- 要素6详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">6</div>
        <h3 class="text-2xl font-bold">简单的启动/暂停/恢复API</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <p class="mb-4">
            智能体本质上就是程序，我们对如何启动、查询、恢复和停止它们有明确的期望。
        </p>

        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/165-pause-resume-animation.gif" 
                 alt="暂停/恢复动画演示" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心要求：</strong> 用户、应用程序、管道和其他智能体应该能够通过简单的API轻松启动智能体。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">关键功能：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li>智能体及其编排的确定性代码应该能够在需要长时间运行的操作时暂停智能体</li>
                <li>像webhooks这样的外部触发器应该使智能体能够从上次停止的地方恢复，而无需与智能体编排器深度集成</li>
            </ul>
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>相关要素：</strong> 这与<a href="#factor-5" class="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300">要素5 - 统一执行状态和业务状态</a>和<a href="#factor-8" class="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300">要素8 - 掌控控制流</a>密切相关，但可以独立实现。
            </p>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg">
            <p class="text-yellow-800 dark:text-yellow-200">
                <strong>重要提示：</strong> 通常AI编排器会允许暂停和恢复，但在工具选择和工具执行之间可能不支持。另请参阅<a href="#factor-7" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素7 - 通过工具调用联系人类</a>和<a href="#factor-11" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素11 - 从任何地方触发，在用户所在的地方与他们会面</a>。
            </p>
        </div>
    </div>
</div>
<!-- 要素7详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">7</div>
        <h3 class="text-2xl font-bold">通过工具调用联系人类</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <p class="mb-4">
            默认情况下，LLM API依赖于一个关键的高风险标记选择：我们是返回纯文本内容，还是返回结构化数据？
        </p>

        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/170-contact-humans-with-tools.png" 
                 alt="人机交互工具调用示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 通过让LLM始终输出JSON，并使用自然语言标记（如`request_human_input`或`done_for_now`）来声明意图，可能会获得更好的结果。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">代码示例：</h4>
            <pre class="bg-gray-800 text-gray-100 p-4 rounded-lg overflow-x-auto">
                <code class="language-python">
class Options:
    urgency: Literal["low", "medium", "high"]
    format: Literal["free_text", "yes_no", "multiple_choice"]
    choices: List[str]

class RequestHumanInput:
    intent: "request_human_input"
    question: str
    context: str
    options: Options
                </code>
            </pre>
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">主要优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>清晰的指令：</strong> 不同类型的人机交互工具允许LLM提供更具体的指令</li>
                <li><strong>内外循环：</strong> 支持传统chatGPT风格界面之外的工作流程</li>
                <li><strong>多人访问：</strong> 可以轻松跟踪和协调来自不同人的输入</li>
                <li><strong>多智能体：</strong> 简单的抽象可以轻松扩展到支持智能体之间的请求和响应</li>
                <li><strong>持久性：</strong> 与要素6结合，创建持久、可靠且可自省的多参与者工作流程</li>
            </ul>
        </div>

        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/175-outer-loop-agents.png" 
                 alt="外循环智能体示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg">
            <p class="text-yellow-800 dark:text-yellow-200">
                <strong>相关要素：</strong> 这与<a href="#factor-5" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素5</a>、<a href="#factor-8" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素8</a>、<a href="#factor-3" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素3</a>和<a href="#factor-4" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素4</a>密切相关，并且与<a href="#factor-11" class="text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-300">要素11</a>配合使用效果很好。
            </p>
        </div>
    </div>
</div>
<!-- 要素8详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">8</div>
        <h3 class="text-2xl font-bold">掌控控制流</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/180-control-flow.png" 
                 alt="控制流示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 通过掌控控制流，你可以实现许多有趣的功能，包括自定义工具调用结果的总结和缓存、LLM作为结构化输出的判断者、上下文窗口压缩等。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">代码示例：</h4>
            <pre class="bg-gray-800 text-gray-100 p-4 rounded-lg overflow-x-auto">
                <code class="language-python">
def handle_next_step(thread: Thread):
    while True:
        next_step = await determine_next_step(thread_to_prompt(thread))
        
        if next_step.intent == 'request_clarification':
            # 请求澄清，等待人类响应
            thread.events.append({
                type: 'request_clarification',
                data: nextStep,
            })
            await send_message_to_human(next_step)
            await db.save_thread(thread)
            break
            
        elif next_step.intent == 'fetch_open_issues':
            # 同步获取问题列表
            thread.events.append({
                type: 'fetch_open_issues',
                data: next_step,
            })
            issues = await linear_client.issues()
            thread.events.append({
                type: 'fetch_open_issues_result',
                data: issues,
            })
            continue
            
        elif next_step.intent == 'create_issue':
            # 创建问题，需要人类批准
            thread.events.append({
                type: 'create_issue',
                data: next_step,
            })
            await request_human_approval(next_step)
            await db.save_thread(thread)
            break
                </code>
            </pre>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-yellow-600 dark:text-yellow-400">关键优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li>可以在工具选择和工具调用之间中断和恢复代理的流程</li>
                <li>支持更自然的对话和工作流程</li>
                <li>允许在关键操作前进行审查和批准</li>
                <li>避免被迫在内存中暂停任务或限制代理只能执行低风险操作</li>
            </ul>
        </div>

        <div class="bg-green-50 dark:bg-green-900 p-4 rounded-lg">
            <p class="text-green-800 dark:text-green-200">
                <strong>相关要素：</strong> 这与<a href="#factor-5" class="text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300">要素5</a>和<a href="#factor-6" class="text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300">要素6</a>密切相关，但可以独立实现。
            </p>
        </div>
    </div>
</div>
<!-- 要素9详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">9</div>
        <h3 class="text-2xl font-bold">错误处理与上下文</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/195-factor-9-errors.gif" 
                 alt="错误处理演示" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 通过将错误信息整合到上下文窗口中，LLM可以读取错误消息或堆栈跟踪，并在后续工具调用中做出相应的调整，实现自我修复能力。
            </p>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">基础实现：</h4>
            <pre class="bg-gray-800 text-gray-100 p-4 rounded-lg overflow-x-auto">
                <code class="language-python">
thread = {"events": [inital_message]}

while True:
    next_step = await determine_next_step(thread_to_prompt(thread))
    thread["events"].append({
        "type": next_step.intent,
        "data": next_step,
    })
    try:
        result = await handle_next_step(thread, next_step)
    except Exception as e:
        thread["events"].append({
            "type": 'error',
            "data": format_error(e),
        })
                </code>
            </pre>
        </div>

        <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-blue-600 dark:text-blue-400">错误计数实现：</h4>
            <pre class="bg-gray-800 text-gray-100 p-4 rounded-lg overflow-x-auto">
                <code class="language-python">
consecutive_errors = 0

while True:
    try:
        result = await handle_next_step(thread, next_step)
        thread["events"].append({
            "type": next_step.intent + '_result',
            data: result,
        })
        consecutive_errors = 0
    except Exception as e:
        consecutive_errors += 1
        if consecutive_errors < 3:
            thread["events"].append({
                "type": 'error',
                "data": format_error(e),
            })
        else:
            break
                </code>
            </pre>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-yellow-600 dark:text-yellow-400">主要优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>自我修复：</strong> LLM可以读取错误消息并确定在后续工具调用中需要更改的内容</li>
                <li><strong>持久性：</strong> 即使一个工具调用失败，智能体也可以继续运行</li>
            </ul>
        </div>

        <div class="bg-red-50 dark:bg-red-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-red-600 dark:text-red-400">注意事项：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li>过度使用可能导致智能体陷入循环，重复相同的错误</li>
                <li>需要结合<a href="#factor-8" class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300">要素8</a>和<a href="#factor-3" class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300">要素3</a>来优化错误处理</li>
                <li>最佳实践是采用<a href="#factor-10" class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300">要素10</a>的小型、专注的智能体</li>
            </ul>
        </div>

        <div class="bg-green-50 dark:bg-green-900 p-4 rounded-lg">
            <p class="text-green-800 dark:text-green-200">
                <strong>最佳实践：</strong> 当达到连续错误阈值时，可以考虑将控制权转交给人类，无论是通过模型决策还是确定性的控制流接管。
            </p>
        </div>
    </div>
</div>

<!-- 要素10详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">10</div>
        <h3 class="text-2xl font-bold">小型专注智能体</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/1a0-small-focused-agents.png" 
                 alt="小型专注智能体示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心洞察：</strong> 随着任务规模和复杂度的增加，所需的步骤也会增加，这意味着需要更长的上下文窗口。而上下文窗口越大，LLM越容易迷失或失去焦点。通过将智能体限制在特定领域，保持3-10步（最多20步）的规模，我们可以保持上下文窗口的可管理性和LLM的高性能。
            </p>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-yellow-600 dark:text-yellow-400">小型专注智能体的优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>可管理的上下文：</strong> 较小的上下文窗口意味着更好的LLM性能</li>
                <li><strong>明确的职责：</strong> 每个智能体都有明确定义的范围和目的</li>
                <li><strong>更好的可靠性：</strong> 在复杂工作流程中迷失的可能性更小</li>
                <li><strong>更容易测试：</strong> 更容易测试和验证特定功能</li>
                <li><strong>改进的调试：</strong> 问题发生时更容易识别和修复</li>
            </ul>
        </div>

        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/1a5-agent-scope-grow.gif" 
                 alt="智能体范围增长演示" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-green-50 dark:bg-green-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-green-600 dark:text-green-400">关于LLM发展的思考：</h4>
            <p class="text-green-800 dark:text-green-200">
                即使LLM变得更智能，能够处理100步以上的工作流程，小型专注的方法仍然重要。这种方法确保你现在就能获得结果，同时为LLM上下文窗口变得更可靠时逐步扩展智能体范围做好准备。
            </p>
        </div>

        <div class="bg-purple-50 dark:bg-purple-900 p-4 rounded-lg">
            <blockquote class="border-l-4 border-purple-500 pl-4 italic">
                <p class="text-purple-800 dark:text-purple-200">
                    "我感觉到，在AI构建中，最神奇的时刻往往出现在我真正、真正、真正接近模型能力边界的时候。"
                </p>
                <footer class="text-sm text-purple-600 dark:text-purple-400 mt-2">
                    — NotebookLM团队
                </footer>
            </blockquote>
        </div>
    </div>
</div>
<!-- 要素11详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">11</div>
        <h3 class="text-2xl font-bold">随处触发，触达用户</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/1b0-trigger-from-anywhere.png" 
                 alt="随处触发示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>核心概念：</strong> 通过实现<a href="#factor-6" class="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300">要素6</a>（简单的启动/暂停/恢复API）和<a href="#factor-7" class="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300">要素7</a>（通过工具调用联系人类），你可以让用户从任何渠道触发智能体，并获得响应。
            </p>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg mb-6">
            <h4 class="font-bold mb-3 text-yellow-600 dark:text-yellow-400">主要优势：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li><strong>触达用户所在之处：</strong> 帮助构建感觉像真实人类或至少像数字同事的AI应用</li>
                <li><strong>外部循环智能体：</strong> 使智能体能够被非人类触发（如事件、定时任务、故障等），在关键点可以联系人类寻求帮助、反馈或批准</li>
                <li><strong>高风险工具：</strong> 如果能够快速联系到各种人类，可以给智能体提供更高风险操作的访问权限，如发送外部邮件、更新生产数据等</li>
            </ul>
        </div>

        <div class="bg-green-50 dark:bg-green-900 p-4 rounded-lg">
            <p class="text-green-800 dark:text-green-200">
                <strong>实现建议：</strong> 通过保持清晰的标准，你可以获得可审计性和对执行更大更好事情的智能体的信心。
            </p>
        </div>
    </div>
</div>
<!-- 要素12详解 -->
<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-8 card-hover">
    <div class="flex items-center mb-4">
        <div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center mr-3 text-lg">12</div>
        <h3 class="text-2xl font-bold">无状态归约器</h3>
    </div>
    <div class="prose dark:prose-invert max-w-none">
        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/1c0-stateless-reducer.png" 
                 alt="无状态归约器示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="my-6">
            <img src="https://github.com/humanlayer/12-factor-agents/raw/main/img/1c5-agent-foldl.png" 
                 alt="智能体foldl示意图" 
                 class="rounded-lg shadow-md w-full h-auto object-contain max-w-5xl mx-auto">
        </div>

        <div class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg mb-6">
            <p class="text-blue-800 dark:text-blue-200">
                <strong>设计理念：</strong> 将智能体设计为无状态归约器，使其能够以函数式编程的方式处理输入和输出，提高代码的可维护性和可测试性。
            </p>
        </div>

        <div class="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg">
            <h4 class="font-bold mb-3 text-yellow-600 dark:text-yellow-400">实现建议：</h4>
            <ul class="list-disc pl-6 space-y-2">
                <li>使用函数式编程范式设计智能体</li>
                <li>避免维护内部状态</li>
                <li>确保每个操作都是可预测和可测试的</li>
                <li>使用纯函数处理输入和输出</li>
            </ul>
        </div>
    </div>
</div>



        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-white dark:bg-gray-800 py-8">
        <div class="container mx-auto px-4 text-center">
            <p class="text-gray-600 dark:text-gray-300">
                © 2024 智能体12要素 | 
                <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="text-blue-500 hover:text-blue-600">
                    CC BY-SA 4.0
                </a>
            </p>
        </div>
    </footer>

    <script>
        // 主题切换
        const themeToggle = document.getElementById('themeToggle');
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        
        function toggleTheme() {
            document.body.classList.toggle('dark');
        }
        
        themeToggle.addEventListener('click', toggleTheme);
        
        // 初始化主题
        if (prefersDarkScheme.matches) {
            document.body.classList.add('dark');
        }
    </script>
</body>
</html>
